package eu.nets.factory.gateway.web;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.reflections.Reflections;
import org.slf4j.Logger;
import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.core.ParameterNameDiscoverer;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

import static java.util.Arrays.asList;
import static java.util.Optional.empty;
import static java.util.Optional.of;
import static java.util.regex.Pattern.compile;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections.ListUtils.union;
import static org.apache.commons.lang3.StringUtils.join;
import static org.apache.commons.lang3.StringUtils.trimToEmpty;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * @see DataJs
 */
public class DataJsGenerator {
    private static final Logger log = getLogger(DataJsGenerator.class);

    private static Pattern pathPattern = compile("[-./a-zA-Z0-9\\{\\}]+");

    private final String objectName;

    private final String serviceName;

    private final Class<?> packageName;

    private final Optional<Function<DataMethod, Boolean>> methodFilter;

    public DataJsGenerator(String objectName, String serviceName, Class<?> packageName) {
        this.objectName = objectName;
        this.serviceName = serviceName;
        this.packageName = packageName;
        this.methodFilter = Optional.empty();
    }

    private DataJsGenerator(String objectName, String serviceName, Class<?> packageName,
                            Optional<Function<DataMethod, Boolean>> methodFilter) {
        this.objectName = objectName;
        this.serviceName = serviceName;
        this.packageName = packageName;
        this.methodFilter = methodFilter;
    }

    public DataJsGenerator withDataMethodFilter(Function<DataMethod, Boolean> methodFilter) {
        return new DataJsGenerator(objectName, serviceName, packageName, of(methodFilter));
    }

    public void generateJs(GeneratorWriter writer) throws Exception {
        Reflections reflections = new Reflections(packageName.getPackage().getName());

        Set<Class<?>> controllers = new TreeSet<>((o1, o2) -> o1.getName().compareTo(o2.getName()));
        Set<Class<?>> x = reflections.getTypesAnnotatedWith(Controller.class);
        controllers.addAll(x);

        writer.
                println("'use strict'; // Generated by " + DataJsGenerator.class.getSimpleName()).
                println("function " + objectName + "($http, prefix) {").
                push().
                println("this.$http = $http;").
                println("prefix = typeof prefix === 'string' ? prefix : '';").
                println("this.resolve = {};").
                println("var getData = function (res) {").
                println("  return res.data;").
                println("};");

        for (Class<?> controller : controllers) {
            if (ignored(controller)) {
                continue;
            }

            String ctrl = controller.getSimpleName();

            Map<String, DataMethod> keys = new TreeMap<>();
            Set<DataMethod> methods = new TreeSet<>();

            for (Method method : controller.getDeclaredMethods()) {
                RequestMapping requestMapping = method.getAnnotation(RequestMapping.class);
                if (requestMapping == null || ignored(method)) {
                    continue;
                }

                String verb = null;
                for (RequestMethod requestMethod : requestMapping.method()) {
                    if (verb != null) {
                        log.warn("Ignoring method: multiple http methods for controller method: " + ctrl + "." + method.getName());
                        continue;
                    }
                    verb = requestMethod.name();
                }
                if (verb == null) {
                    verb = "GET";
                }

                String path = buildPath(controller, method);

                if (path == null) {
                    continue;
                }

                ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();
                String[] parameterNames = parameterNameDiscoverer.getParameterNames(method);
                List<String> queryVariables = new ArrayList<>();
                Parameter[] parameters = method.getParameters();
                Optional<String> payloadName = empty();
                for (int i = 0; i < parameters.length; i++) {
                    Parameter parameter = parameters[i];
                    RequestParam requestParam = parameter.getAnnotation(RequestParam.class);
                    if (requestParam != null) {
                        String name = requestParam.value();
                        name = name.equals("") ? parameterNames[i] : name;
                        queryVariables.add(name);
                    }

                    RequestBody requestBody = parameter.getAnnotation(RequestBody.class);
                    if (requestBody != null) {
                        payloadName = of(parameterNames[i]);
                    }
                }

                List<String> queryConstants = new ArrayList<>(asList(requestMapping.params()));
                DataMethod m = new DataMethod(ctrl, method.getName(), verb, path, payloadName, queryVariables, queryConstants);

                Boolean accept = methodFilter.map(f -> f.apply(m)).orElse(false);

                if (!accept) {
                    log.debug("Method not accepted by filter: {}" + m.key);
                    continue;
                }

                methods.add(m);

                DataMethod other = keys.get(m.key);
                if (other != null) {
                    throw new RuntimeException("Duplicate key: " + m.key + ", A:" + m.controller + "." + m.name + ", B: " + other.controller + "." + other.name);
                }
                keys.put(m.key, m);
            }

            if (methods.isEmpty()) {
                continue;
            }

            writer.println("this." + ctrl + " = {};");
            for (DataMethod m : methods) {
                List<String> args = new ArrayList<>();
                args.addAll(m.pathParams);
                args.addAll(m.queryVariables);

                String payloadName = m.payloadName.orElse("payload");
                if (m.hasPayload()) {
                    args.add(payloadName);
                }

                writer.
                        println("this." + ctrl + "." + m.name + " = function(" + join(args, ", ") + ") {").
                        push().
                        println("var req = {};").
                        println("req.method = '" + m.verb + "';").
                        println("req.url = prefix + '" + m.url + "';");
                for (String pathParam : m.pathParams) {
                    writer.println("req.url = req.url.replace(/{" + pathParam + "}/, " + pathParam + ");");
                }
                if (m.hasPayload()) {
                    writer.println("req.data = " + payloadName + ";");
                }
                writer.println("req.params = {};");
                m.queryVariables.stream().map(p -> "req.params." + p + " = " + p + ";").forEach(writer::println);
                m.queryConstants.stream().map(p -> "req.params." + p.key + " = '" + p.value + "';").forEach(writer::println);
                writer.
                        println("return $http(req).then(getData);").
                        pop().
                        println("};");
            }

            writer.println("var " + ctrl + " = this." + ctrl + ";");
            writer.println("this.resolve." + ctrl + " = {};");
            for (DataMethod m : methods) {
                if (!m.generateResolve() || m.hasPayload()) {
                    continue;
                }

                List<String> args = new ArrayList<>();
                args.addAll(m.pathParams);
                args.addAll(m.queryVariables);

                String a = join(args.stream().map(p -> "$route.current.params." + p).collect(toList()), ", ");
                writer.
                        println("this.resolve." + ctrl + "." + m.name + " = function(" + serviceName + ", $route) {").
                        println("  return " + ctrl + "." + m.name + "(" + a + ");").
                        println("};");
            }
            writer.
                    pop().
                    println("}");
        }
    }

    private static boolean ignored(Class<?> klass) {
        DataJs dataJs = klass.getAnnotation(DataJs.class);
        return dataJs != null && dataJs.ignore();
    }

    private static boolean ignored(Method method) {
        DataJs dataJs = method.getAnnotation(DataJs.class);
        return dataJs != null && dataJs.ignore();
    }

    private static String buildPath(Class<?> ctrl, Method method) {

        String controllerPath = buildPath(ctrl.getSimpleName(), ctrl.getAnnotation(RequestMapping.class));

        if (controllerPath == null) {
            return null;
        }

        String methodPath = buildPath(method.getName(), method.getAnnotation(RequestMapping.class));

        if (methodPath == null) {
            return null;
        }

        return controllerPath + methodPath;
    }

    private static String buildPath(String name, RequestMapping requestMapping) {
        if (requestMapping == null) {
            return "";
        }

        String[] values = requestMapping.value();

        if (values.length == 0) {
            return null;
        }

        if (values.length > 1) {
            log.debug("{}, Multiple request mappings, using first.", name);
        }

        String path = trimToEmpty(values[0]);

        if (path.endsWith("*")) {
            path = path.substring(0, path.length() - 1);
        }

        if (path.endsWith("/")) {
            path = path.substring(0, path.length() - 1);
        }

        if (!path.startsWith("/")) {
            path = "/" + path;
        }

        if (!pathPattern.matcher(path).matches()) {
            log.warn("{}: Not a valid path pattern: {}, must match {}", name, path, pathPattern.pattern());
            return null;
        }

        return path;
    }

    public static class QueryArgument {
        public final String key;

        public final String value;

        public QueryArgument(String key, String value) {
            this.key = key;
            this.value = value;
        }
    }

    public static class DataMethod implements Comparable<DataMethod> {
        public final String controller;

        public final String name;

        public final String verb;

        public final String url;

        public final List<String> pathParams = new ArrayList<>();

        public final Optional<String> payloadName;

        public final List<String> queryVariables;

        public final List<QueryArgument> queryConstants = new ArrayList<>();

        public final String key;

        public static final Pattern pattern = compile("\\{([a-zA-Z0-9]*)\\}");

        public DataMethod(String controller, String name, String verb, String url, Optional<String> payloadName, List<String> queryVariables, List<String> queryConstants) {
            this.controller = controller;
            this.name = name;
            this.verb = verb;
            this.url = url;
            this.payloadName = payloadName;
            this.key = verb + " " + url + (queryVariables.isEmpty() ? "" : "?" + join(union(queryVariables, queryConstants), '&'));

            Matcher matcher = pattern.matcher(url);

            while (matcher.find()) {
                String param = matcher.group(1);
                pathParams.add(param);
            }

            for (String param : queryConstants) {
                int i = param.indexOf('=');
                if (i == -1) {
                    continue;
                }

                this.queryConstants.add(new QueryArgument(param.substring(0, i), param.substring(i + 1, param.length())));
            }

            this.queryVariables = queryVariables;
        }

        @Override
        public int compareTo(DataMethod o) {
            int i = name.compareTo(o.name);
            return i != 0 ? i : key.compareTo(o.key);
        }

        private static final List<String> verbsWithPayload = asList("POST", "PUT", "PATCH");

        private static final List<String> verbsToGenerateResolveMethodsFor = asList("GET", "HEAD");

        public boolean hasPayload() {
            return verbsWithPayload.contains(verb);
        }

        public boolean generateResolve() {
            return verbsToGenerateResolveMethodsFor.contains(verb);
        }

        @Override
        public String toString() {
            return ToStringBuilder.reflectionToString(this);
        }
    }
}
